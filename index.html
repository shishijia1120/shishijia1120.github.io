<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-JavaScript微软官方教程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/29/JavaScript%E5%BE%AE%E8%BD%AF%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-03-29T13:53:21.000Z" itemprop="datePublished">2021-03-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/29/JavaScript%E5%BE%AE%E8%BD%AF%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B/">JavaScript微软官方教程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/microsoft/beginners-intro-javascript-node">https://github.com/microsoft/beginners-intro-javascript-node</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">https://developer.mozilla.org/en-US/docs/Web/JavaScript</a></li>
</ul>
</blockquote>
<h2 id="Functions-5-Things-To-Know"><a href="#Functions-5-Things-To-Know" class="headerlink" title="Functions: 5 Things To Know!"></a>Functions: 5 Things To Know!</h2><h3 id="1-Basic-What-are-Functions"><a href="#1-Basic-What-are-Functions" class="headerlink" title="1. Basic: What are Functions?"></a>1. Basic: What are Functions?</h3><ul>
<li>函数是基本的代码块，用来执行一系列语句，将它们抽象为一个可复用函数，会得到两个好处。可读性和复用性、可维护性。</li>
</ul>
<h3 id="2-Syntax-Define-amp-Invoke-your-functions"><a href="#2-Syntax-Define-amp-Invoke-your-functions" class="headerlink" title="2.  Syntax: Define &amp; Invoke your functions"></a>2.  Syntax: Define &amp; Invoke your functions</h3><ul>
<li><code>function</code>  keyword</li>
<li><code>funtion name</code>  is used to invoke functions</li>
<li><code>funtion parameters</code> are placeholders for input</li>
<li>closing <code>brace</code> terminates function(if no return statements are encountered)</li>
<li>function <code>return</code>  defines exit points,placeholder for output(result) data.</li>
</ul>
<h3 id="3-Naming-Conventions-amp-Tips"><a href="#3-Naming-Conventions-amp-Tips" class="headerlink" title="3. Naming: Conventions &amp; Tips"></a>3. Naming: Conventions &amp; Tips</h3><h4 id="Like-variable-name-conventions"><a href="#Like-variable-name-conventions" class="headerlink" title="Like variable name conventions"></a>Like variable name conventions</h4><ul>
<li>Use alphabets,numbers,$and_</li>
<li>No other special characters allowed.</li>
</ul>
<h4 id="Function-“-name”-property"><a href="#Function-“-name”-property" class="headerlink" title="Function “.name” property"></a>Function “.name” property</h4><ul>
<li>returns the name of the function</li>
<li>returns “anonymous” for anonymous functions</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sayHello.name);	<span class="comment">//sayHello</span></span><br></pre></td></tr></table></figure>

<h4 id="Anonymous-functions"><a href="#Anonymous-functions" class="headerlink" title="Anonymous functions"></a>Anonymous functions</h4><ul>
<li>no covered in this module</li>
</ul>
<h3 id="4-Parameters-Providing-inputs"><a href="#4-Parameters-Providing-inputs" class="headerlink" title="4. Parameters: Providing inputs"></a>4. Parameters: Providing inputs</h3><h4 id="Are-placeholders-for-input-values"><a href="#Are-placeholders-for-input-values" class="headerlink" title="Are placeholders for input values"></a>Are placeholders for input values</h4><h4 id="Arguments-type-numbers-are-not-checked-against-definitions"><a href="#Arguments-type-numbers-are-not-checked-against-definitions" class="headerlink" title="Arguments type/numbers are not checked against definitions"></a>Arguments type/numbers are not checked against definitions</h4><ul>
<li>Missing values will be set to undefined!</li>
<li>This can have unanticipated results if you don’t validate your arguments within the funtion.</li>
</ul>
<h3 id="5-Return-Providing-outputs-exit-points"><a href="#5-Return-Providing-outputs-exit-points" class="headerlink" title="5. Return: Providing outputs,exit points"></a>5. Return: Providing outputs,exit points</h3><h4 id="Exit-point-for-functions"><a href="#Exit-point-for-functions" class="headerlink" title="Exit point for functions"></a>Exit point for functions</h4><ul>
<li><p>The return statement is optional.</p>
<p>There is an implicit return after the last statement defined within the {}</p>
</li>
<li><p>Use return statements to return relevant output (results) to the invoker.</p>
</li>
<li><p>if no return statement is defined, the returned result is undefined.</p>
</li>
</ul>
<h2 id="Arrow-Function"><a href="#Arrow-Function" class="headerlink" title="Arrow Function"></a>Arrow Function</h2><ul>
<li> Changes to the <em>this</em> context</li>
</ul>
<ul>
<li>Support implicit return values</li>
</ul>
<ul>
<li>Must be assigned to a variable, or immediately used</li>
</ul>
<ul>
<li>Reduction in characters typed</li>
</ul>
<h3 id="this-context"><a href="#this-context" class="headerlink" title="this context"></a>this context</h3><p>This context in a traditional JavaScript functions is defined where that functions is called, whereas in an arrow function it’s inherited from parent scope.</p>
<p>？？？？？？</p>
<ul>
<li>inherited from parent scope</li>
<li>Cannot be changed</li>
<li>Maintained when function is passed as a reference</li>
</ul>
<h3 id="Implicit-Return"><a href="#Implicit-Return" class="headerlink" title="Implicit Return"></a>Implicit Return</h3><ul>
<li><p>Single line functions return statement result</p>
</li>
<li><p>Use {} to introduce multiple lines</p>
</li>
</ul>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="1-What-is-JSON"><a href="#1-What-is-JSON" class="headerlink" title="1. What is JSON?"></a>1. What is JSON?</h3><h4 id="JSON-JavaScript-Object-Notation"><a href="#JSON-JavaScript-Object-Notation" class="headerlink" title="JSON=JavaScript Object Notation"></a>JSON=JavaScript Object Notation</h4><ul>
<li><p>Language independent and user-readable.</p>
</li>
<li><p>Depends only on 2 data structures that are found in all modern programming languages.</p>
<ul>
<li><p>Collection of <strong>name-value pairs</strong></p>
</li>
<li><p>Ordered list <strong>of values</strong></p>
</li>
</ul>
<blockquote>
<p>因为键值对只能是单一序列化对象，如果想要在单行字符串装入多个对象，需要使用数组。</p>
</blockquote>
</li>
</ul>
<h3 id="2-JSON-Format"><a href="#2-JSON-Format" class="headerlink" title="2. JSON Format"></a>2. JSON Format</h3><ul>
<li>Data in name-value pairs that are separated by commas</li>
<li>{} enclose single objects</li>
<li>[] enclose multi-item arrays</li>
</ul>
<h3 id="3-stringify-Serialize-Object-to-JSON"><a href="#3-stringify-Serialize-Object-to-JSON" class="headerlink" title="3. stringify: Serialize Object to JSON"></a>3. stringify: Serialize Object to JSON</h3><ul>
<li><p>Serialize a JavaScript Object into an equivalent text string</p>
</li>
<li><p>Serialize a collection of JavaScript Objects into an ordered list</p>
</li>
</ul>
<h3 id="4-parse-Deserialize-JSON-to-Object"><a href="#4-parse-Deserialize-JSON-to-Object" class="headerlink" title="4. parse: Deserialize JSON to Object"></a>4. parse: Deserialize JSON to Object</h3><ul>
<li>Deserialize a JSON-formatted text string into a JavaScript object</li>
<li>Deserialize a JSON-formatted text string into a JavaScript array</li>
</ul>
<blockquote>
<p>如何将JSON转换为函数对象？</p>
<ul>
<li>实现的最好方式是用结构体，能够选择序列化的属性和数据，然后转回定义的函数中，要用自定义构造函数。？？？？？</li>
</ul>
</blockquote>
<h2 id="Objects-6-Things-To-Know"><a href="#Objects-6-Things-To-Know" class="headerlink" title="Objects: 6 Things To Know"></a>Objects: 6 Things To Know</h2><h3 id="1-Basics-What-are-Objects"><a href="#1-Basics-What-are-Objects" class="headerlink" title="1. Basics: What are Objects"></a>1. Basics: What are Objects</h3><ul>
<li>Representations of real world objects-using code!</li>
<li>JavaScript objects have associated properties</li>
<li>JavaScript objects have associated methods</li>
</ul>
<h3 id="2-Syntax-Object-Definition"><a href="#2-Syntax-Object-Definition" class="headerlink" title="2. Syntax: Object Definition"></a>2. Syntax: Object Definition</h3><ul>
<li><p>Collection of unordered name=value pairs!</p>
</li>
<li><p>This is an example of an object literal</p>
<p>It’s the easiest way to create a JavaScript object at definition</p>
<p>Just enclose name-value pairs in {}–separated by commas</p>
</li>
<li><p>You can also create objects in other ways</p>
<p>using what’s called constructors and new keyword</p>
</li>
</ul>
<h3 id="3-Creation-literals-amp-Constructors"><a href="#3-Creation-literals-amp-Constructors" class="headerlink" title="3. Creation: literals &amp; Constructors"></a>3. Creation: literals &amp; Constructors</h3><p>有两种创建对象的方式：使用字面量和构造函数。字面量使用简单，但构造体可以有很多属性，方便让你执行继承之类事情。(原型链)</p>
<h3 id="4-Properties-Associated-Variables"><a href="#4-Properties-Associated-Variables" class="headerlink" title="4. Properties: Associated Variables"></a>4. Properties: Associated Variables</h3><ul>
<li><p>Properties have immutable names and mutable values</p>
<p>Naming uses the same conventions as variables</p>
</li>
<li><p>Access Approach 1: Dot notation</p>
<p>Use: <object>.<name>(like with namespaces)</p>
</li>
<li><p>Access Approach 2: Bracket notation</p>
<p>Use: <object>[“name”] (like with hashmaps)</p>
</li>
</ul>
<h3 id="5-Methods-Associated-Functions"><a href="#5-Methods-Associated-Functions" class="headerlink" title="5. Methods: Associated Functions"></a>5. Methods: Associated Functions</h3><ul>
<li><p>Methods are special properties whose values are function definitions</p>
</li>
<li><p>Access methods just like properties</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ex: book.checkIn gives [<span class="built_in">Function</span>:checkIn]</span><br><span class="line">Ex: book[<span class="string">&quot;checkIn&quot;</span>] gives [<span class="built_in">Function</span>: checkIn]</span><br></pre></td></tr></table></figure></li>
<li><p>Invoke methods just like functions</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ex: book.checkIn() excutes that method</span><br><span class="line">Ex: book[<span class="string">&quot;checkIn&quot;</span>]() does likewise</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-“this”-Associated-Context"><a href="#6-“this”-Associated-Context" class="headerlink" title="6. “this”: Associated Context"></a>6. “this”: Associated Context</h3><blockquote>
<p><em>this</em> is a keyword that sets the runtime context for the function.</p>
<p>It’s a way for the function to be able to get access to other data or functions in it’s runtime scope.</p>
</blockquote>
<ul>
<li><p>Functions need access to runtime context.</p>
<p>(Object) methods may need access to peer property values</p>
<p>(Standalone) functions may use global variables in execution</p>
</li>
<li><p>“this” maps to relevant context at runtime</p>
<ul>
<li>Maps to enclosing object– for object methods</li>
<li>Maps to global–for standalone functions</li>
<li>May be undefined(strict mode) or changed(e.g., use apply)??????</li>
</ul>
</li>
<li><p>About the global object</p>
<ul>
<li><p>defaults to window object in browser runtime</p>
</li>
<li><p>defaults to window object in browser runtime</p>
</li>
<li><p>use “globalThis” to reference the global object consistently</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>当你在函数中使用this引用函数运行时上下文。</p>
<ul>
<li>如果函数存在于对象中，接着this的运行时上下文就会绑定到对象自身；</li>
<li>如果在对象外使用，运行时上下文会绑定到全局作用域，this就会返回全局对象。</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bookObj = &#123;</span><br><span class="line">    checkIn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;\n\n this is:&quot;</span>,bookObj.checkIn());<span class="comment">//this is: &#123;checkIn:[Function: checkIn]&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(bookObj.checkIn() === globalThis);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anotherCheckIn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;\n\n this is:&quot;</span>,anotherCheckIn());</span><br><span class="line"><span class="built_in">console</span>.log(anotherCheckIn() === globalThis);</span><br></pre></td></tr></table></figure>











      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/29/JavaScript%E5%BE%AE%E8%BD%AF%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B/" data-id="ckmunmo930000pcuu1a0ddqnq" data-title="JavaScript微软官方教程" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-流畅的Python" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/29/%E6%B5%81%E7%95%85%E7%9A%84Python/" class="article-date">
  <time class="dt-published" datetime="2021-03-29T13:44:22.000Z" itemprop="datePublished">2021-03-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/">书籍笔记</a>►<a class="article-category-link" href="/categories/%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/%E6%B5%81%E7%A8%8B%E7%9A%84Python/">流程的Python</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/">Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/29/%E6%B5%81%E7%95%85%E7%9A%84Python/">流畅的Python</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="2-序列构成的数组"><a href="#2-序列构成的数组" class="headerlink" title="2 序列构成的数组"></a>2 序列构成的数组</h2><p>​    Python中不管是哪种序列数据，字符串、列表、字节序列、数组、XML元素，抑或是数据库查询结果，它们都共用一套丰富操作：迭代、切片、排序，还有拼接。</p>
<h3 id="2-1-内置序列类型概览"><a href="#2-1-内置序列类型概览" class="headerlink" title="2.1 内置序列类型概览"></a>2.1 内置序列类型概览</h3><ul>
<li><p>容器序列</p>
<p>list、tuple和collections.deque这些序列能存放不同类型的数据。</p>
</li>
<li><p>扁平序列</p>
<p>str、bytes、bytearray、memoryview和array.array，这类序列只能容纳一种类型。</p>
</li>
</ul>
<p>容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不是引用。扁平序列其实是一段连续的内存空间，它里面只能存放诸如字符、字节和数值这种基础类型。</p>
<p>序列类型还能按照能否被修改来分类。</p>
<ul>
<li><p>可变序列</p>
<p>list、bytearray、array.array、collections.deque和memoryview。</p>
</li>
<li><p>不可变序列</p>
<p>tuple、str和bytes。</p>
</li>
</ul>
<h3 id="2-2-列表推导和生成器表达式"><a href="#2-2-列表推导和生成器表达式" class="headerlink" title="2.2 列表推导和生成器表达式"></a>2.2 列表推导和生成器表达式</h3><p>列表推导是构建列表(list)的快捷方式，而生成器表达式则可以用来创建其他任何类型的序列。</p>
<h4 id="2-2-1-列表推导和可读性"><a href="#2-2-1-列表推导和可读性" class="headerlink" title="2.2.1 列表推导和可读性"></a>2.2.1 列表推导和可读性</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;symbols = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">&gt;&gt;&gt;codes = []</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> symbol <span class="keyword">in</span> symbols:</span><br><span class="line">    codes.append(<span class="built_in">ord</span>(symbol))</span><br><span class="line">//列表推导的写法</span><br><span class="line">&gt;&gt;&gt;codes = [<span class="built_in">ord</span>(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols]</span><br></pre></td></tr></table></figure>

<ul>
<li>使用原则：只用列表推导来创建新的列表，并且尽量保持简短，如果列表推导的代码超过了两行，应该考虑是不是用for循环重写了。</li>
<li>列表推导、生成器表达式，以及同它们很相似的集合(set)推导和字典(dict)推导，在Python3中都有了自己的局部作用域。</li>
<li>Python会忽略代码里[ ]、{ }和( )中的换行。</li>
<li>列表推导可以帮助我们把一个序列或是其他可迭代类型中的元素过滤或是加工，然后再新键一个列表。(Python内置的filter和map函数组合起来也能达到这一效果，但可读性不高)。</li>
</ul>
<h4 id="2-2-2-列表推导同filter和map的比较"><a href="#2-2-2-列表推导同filter和map的比较" class="headerlink" title="2.2.2 列表推导同filter和map的比较"></a>2.2.2 列表推导同filter和map的比较</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//列表推导</span><br><span class="line">OAOAOA&gt;&gt;&gt;symbols = <span class="string">&#x27;$#abs&#x27;</span></span><br><span class="line">&gt;&gt;&gt;beyond_ascii = [<span class="built_in">ord</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> symbols <span class="keyword">if</span> <span class="built_in">ord</span>(s) &gt; <span class="number">127</span>]</span><br><span class="line">OAOAOA</span><br><span class="line">//<span class="built_in">filter</span>/<span class="built_in">map</span></span><br><span class="line">&gt;&gt;&gt;beyond_ascii = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> c: c &gt; <span class="number">127</span>,<span class="built_in">map</span>(<span class="built_in">ord</span>,symbols)))</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-笛卡儿积"><a href="#2-2-3-笛卡儿积" class="headerlink" title="2.2.3 笛卡儿积"></a>2.2.3 笛卡儿积</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;colors = [<span class="string">&#x27;black&#x27;</span>,<span class="string">&#x27;white&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;sizes = [<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;L&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;tshirts = [(color,size) <span class="keyword">for</span> color <span class="keyword">in</span> colors <span class="keyword">for</span> size <span class="keyword">in</span> sizes]</span><br><span class="line">[(<span class="string">&#x27;black&#x27;</span>,<span class="string">&#x27;S&#x27;</span>),(<span class="string">&#x27;black&#x27;</span>,<span class="string">&#x27;M&#x27;</span>),(<span class="string">&#x27;black&#x27;</span>,<span class="string">&#x27;L&#x27;</span>),(<span class="string">&#x27;white&#x27;</span>,<span class="string">&#x27;S&#x27;</span>),(<span class="string">&#x27;white&#x27;</span>,<span class="string">&#x27;M&#x27;</span>),(<span class="string">&#x27;white&#x27;</span>,<span class="string">&#x27;L&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-生成器表达式"><a href="#2-2-4-生成器表达式" class="headerlink" title="2.2.4 生成器表达式"></a>2.2.4 生成器表达式</h4><p>虽然也可以用列表推导来初始化元组、数组或其他序列类型，但是生成器表达式是更好的选择。这是因为生成器表达式背后遵守了迭代器协议，可以逐个地产出元素，而不是先建立一个完整的列表，然后再把这个列表传递到某个构造函数里。前面那种方式显然能够节省内存。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;colors = [<span class="string">&#x27;black&#x27;</span>,<span class="string">&#x27;white&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;sizes = [<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;L&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> tshirt <span class="keyword">in</span> (<span class="string">&#x27;%s %s&#x27;</span> %(c,s) <span class="keyword">for</span> c <span class="keyword">in</span> colors <span class="keyword">for</span> s <span class="keyword">in</span> sizes):</span><br><span class="line">    <span class="built_in">print</span>(tshirt)</span><br></pre></td></tr></table></figure>

<p>生成器表达式逐个产出元素，从来不会一次性产出一个含有6个样式的列表。</p>
<h3 id="2-3-元组不仅仅是不可表的列表"><a href="#2-3-元组不仅仅是不可表的列表" class="headerlink" title="2.3 元组不仅仅是不可表的列表"></a>2.3 元组不仅仅是不可表的列表</h3><h4 id="2-3-1-元组和记录"><a href="#2-3-1-元组和记录" class="headerlink" title="2.3.1 元组和记录"></a>2.3.1 元组和记录</h4><p>如果只把元组理解为不可变的列表，那其他信息——它所包含的元素的总数和它们的位置——似乎变得可有可无。但是如果元组当作一些字段的集合，那么数量和位置信息就变得非常重要了。</p>
<p>如果在任何表达式里我们在元组内对元素排序，这些元素所携带的信息就会丢失，因为这些信息是跟它们的位置有关的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;lax_coordinates = (<span class="number">33.9425</span>,-<span class="number">118.408056</span>)</span><br><span class="line">&gt;&gt;&gt;city,year,pop,chg,area = (<span class="string">&#x27;Tokyo&#x27;</span>,<span class="number">2003</span>,<span class="number">0.66</span>,<span class="number">8014</span>)</span><br><span class="line">&gt;&gt;&gt;traveler_ids = [(<span class="string">&#x27;USA&#x27;</span>,<span class="string">&#x27;331195855&#x27;</span>),(<span class="string">&#x27;BRA&#x27;</span>,<span class="string">&#x27;CE342567&#x27;</span>),(<span class="string">&#x27;ESP&#x27;</span>,<span class="string">&#x27;XDA205856&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> passport <span class="keyword">in</span> <span class="built_in">sorted</span>(traveler_ids):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s / %s&#x27;</span> %passport)</span><br><span class="line">...</span><br><span class="line">BRA/ce342567</span><br><span class="line">ESP/<span class="number">31195855</span></span><br><span class="line">USA/<span class="number">31195855</span>	</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> country,_ <span class="keyword">in</span> traveler_ids:</span><br><span class="line">    <span class="built_in">print</span>(country)</span><br><span class="line">USA</span><br><span class="line">BRA</span><br><span class="line">ESP</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-元组拆包"><a href="#2-3-2-元组拆包" class="headerlink" title="2.3.2 元组拆包"></a>2.3.2 元组拆包</h4><p>元组拆包可以应用到任何可迭代对象上，唯一的硬性要求是，被可迭代对象中的元素数量必须要跟接受这些元素的元组的空档数一致。除非我们用*来表示忽略多余的元素。</p>
<p>平行赋值:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;lax_coordinates = (<span class="number">33.9425</span>,-<span class="number">118.408056</span>)</span><br><span class="line">&gt;&gt;&gt;latitude,longitude = lax_coordinates <span class="comment">#元组拆包</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>不使用中间变量交换两个变量的值:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b,a = a,b</span><br></pre></td></tr></table></figure></li>
<li><p>使用*运算符把一个可迭代对象拆开作为函数的参数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">divmod</span>(<span class="number">20</span>,<span class="number">8</span>)</span><br><span class="line">(<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">&gt;&gt;&gt;t = (<span class="number">20</span>,<span class="number">8</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">divmod</span>(*t)</span><br><span class="line">(<span class="number">2</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>使用_占位符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">&gt;&gt;&gt;_,filename = os.path.split(<span class="string">&#x27;/home/luciano/.ssh/idrsa.pub&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;filename</span><br><span class="line"><span class="string">&#x27;idrsa.pub&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用*来处理剩下的元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a,b,*rest = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b,rest</span><br><span class="line">(<span class="number">0</span>,<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<p>在平行赋值中，*前缀只能用在一个变量名前面，但是这个变量可以出现在赋值表达式的任意位置:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a,*body,c,d = <span class="built_in">range</span></span><br><span class="line">&gt;&gt;&gt;a,body,c,d</span><br><span class="line">(<span class="number">0</span>,[<span class="number">1</span>,<span class="number">2</span>],<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-3-3-嵌套元组拆包"><a href="#2-3-3-嵌套元组拆包" class="headerlink" title="2.3.3 嵌套元组拆包"></a>2.3.3 嵌套元组拆包</h4><p>接受表达式的元组可以是嵌套式的，例如(a,b,(c,d))。只要这个接受元组的嵌套结构符合表达式本身的嵌套结构，Python就可以作出正确的对应。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">metro_areas = [</span><br><span class="line">    (<span class="string">&#x27;Tokyo&#x27;</span>,<span class="string">&#x27;JP&#x27;</span>,<span class="number">36.933</span>,(<span class="number">35.689722</span>,<span class="number">139.691667</span>)),</span><br><span class="line">    .......</span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span> name,cc,pop,(latitude,longitude) <span class="keyword">in</span> metro_areas:</span><br><span class="line">    <span class="built_in">print</span>(fmt.<span class="built_in">format</span>(name,latitude,longitude))</span><br></pre></td></tr></table></figure>

<h4 id="2-3-4-具名元组"><a href="#2-3-4-具名元组" class="headerlink" title="2.3.4 具名元组"></a>2.3.4 具名元组</h4><p>。。。</p>
<h4 id="2-3-5-作为不可变列表的元组"><a href="#2-3-5-作为不可变列表的元组" class="headerlink" title="2.3.5 作为不可变列表的元组"></a>2.3.5 作为不可变列表的元组</h4><p>除了跟增减元素相关的方法之外，元组支持列表的其他所有方法。例外，元组没有___reversed__方法，但是这个方法只是个优化而已，reversed(my_tuple)这个用法在没有__reversed__的情况下也是合法的。</p>
<p>。。。</p>
<h3 id="2-4-切片"><a href="#2-4-切片" class="headerlink" title="2.4 切片"></a>2.4 切片</h3><h4 id="2-4-1-为什么切片和区间会忽略最后一个元素"><a href="#2-4-1-为什么切片和区间会忽略最后一个元素" class="headerlink" title="2.4.1 为什么切片和区间会忽略最后一个元素"></a>2.4.1 为什么切片和区间会忽略最后一个元素</h4><p>。。。</p>
<h4 id="2-4-2-对对象进行切片"><a href="#2-4-2-对对象进行切片" class="headerlink" title="2.4.2 对对象进行切片"></a>2.4.2 对对象进行切片</h4><p>。。。</p>
<h4 id="2-4-3-多维切片和省略"><a href="#2-4-3-多维切片和省略" class="headerlink" title="2.4.3 多维切片和省略"></a>2.4.3 多维切片和省略</h4><p>。。。</p>
<h4 id="2-4-4-给切片赋值"><a href="#2-4-4-给切片赋值" class="headerlink" title="2.4.4 给切片赋值"></a>2.4.4 给切片赋值</h4><p>如果把切片放在赋值语句的左边，或把它作为del操作的对象，我们就可以对序列进行嫁接、切除或就地修改操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l =<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<p>如果赋值的对象是一个切片，那么赋值语句的右侧必须是一个可迭代对象。即便只有单独一个值，也要把它转换成可迭代的序列。</p>
<h3 id="2-5-对序列使用-和"><a href="#2-5-对序列使用-和" class="headerlink" title="2.5 对序列使用+和*"></a>2.5 对序列使用+和*</h3><p>+和*都遵循这个规律，不修改原有的操作对象，而是构建一个全新的序列。</p>
<ul>
<li><p>建立由列表组成的列表</p>
<p>有时我们需要初始化一个嵌套着几个列表的列表，想要达成这些目的，最好的选择是使用<strong>列表推导</strong>。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>board = [[<span class="string">&#x27;_&#x27;</span>] * <span class="number">3</span>  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>],[<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>],[<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&#x27;X&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>],[<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;X&#x27;</span>],[<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>]]</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_board = [[<span class="string">&#x27;_&#x27;</span>]*<span class="number">3</span>]*<span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;	weird_board </span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>],[<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>],[<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&#x27;o&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;o&#x27;</span>],[<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;o&#x27;</span>],[<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;o&#x27;</span>]]</span><br></pre></td></tr></table></figure>

<h3 id="2-6-序列的增量赋值"><a href="#2-6-序列的增量赋值" class="headerlink" title="2.6 序列的增量赋值"></a>2.6 序列的增量赋值</h3><p>增量赋值运算符+=和*=的表现取决于它们的第一个操作对象。</p>
<p>+=背后的特殊方法是__iadd__(用于就地加法)。但是如果一个类没有实现这个方法的话，Python会退一步调用__add__。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a+=b</span><br></pre></td></tr></table></figure>

<p>如果a实现了__iadd__方法，就会调用这个方法。同时对可变序列来说，a会就地改动，就像调用了a..extend(b)一样。但是如果a没有实现__iadd__的话，a+=b这个表达式的效果就变得a=a+b一样了；首先计算a+b，得到一个新的对象，然后赋值给a。也就是说，在这个表达式中，变量名会不会被关联到新的对象，完全取决于这个类型有没有实现__iadd__这个方法。</p>
<h4 id="一个关于-的谜题"><a href="#一个关于-的谜题" class="headerlink" title="一个关于+=的谜题"></a>一个关于+=的谜题</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>,<span class="number">2</span>,[<span class="number">30</span>,<span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>] += [<span class="number">50</span>,<span class="number">60</span>]</span><br><span class="line">Traceback(most recent call last):</span><br><span class="line">    File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>,<span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError:<span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,[<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>])</span><br></pre></td></tr></table></figure>



<ul>
<li>str是一个例外，因为对字符串做+=实在太普遍了，所以CPython对它做了优化，为str初始化内存的时候，程序会为它留出额外的可扩展空间，因此进行增量操作的时候，并不会涉及到复制原有字符串到新位置这类操作。</li>
</ul>
<h3 id="2-7-list-sort方法和内置函数sorted"><a href="#2-7-list-sort方法和内置函数sorted" class="headerlink" title="2.7 list.sort方法和内置函数sorted"></a>2.7 list.sort方法和内置函数sorted</h3><ul>
<li>list.sort方法会就地排序列表，也就是说不会把原列表复制一份。这也是这个方法的返回值是None的原因，提醒你本方法不会新建一个列表。</li>
<li>内置函数sorted，它会新建一个列表作为返回值。这个方法可以接受任何形式的可迭代对象作为参数，甚至包括不可变序列或生成器。而不管sort接受的是怎样的参数，它最后都会返回一个列表。</li>
</ul>
<p>不管是list.sort方法还是sorted函数，都有两个可选的关键字参数。</p>
<ul>
<li><p>reverse</p>
<p>如果被设定为True，被排序的序列里的元素会以降序输出。默认为False。</p>
</li>
<li><p>key</p>
<p>一个只有一个参数的函数，这个函数会被用在序列里的每一个元素上，所产生的结果将是排序算法依赖的对比关键字。参数的默认值是恒等函数，也就是默认用元素自己的值来排序。</p>
</li>
</ul>
<h3 id="2-8-用bisect来管理已排序的序列"><a href="#2-8-用bisect来管理已排序的序列" class="headerlink" title="2.8 用bisect来管理已排序的序列"></a>2.8 用bisect来管理已排序的序列</h3><p>。。。</p>
<h3 id="2-9-当列表不是首选时"><a href="#2-9-当列表不是首选时" class="headerlink" title="2.9 当列表不是首选时"></a>2.9 当列表不是首选时</h3><h4 id="2-9-1-数组"><a href="#2-9-1-数组" class="headerlink" title="2.9.1 数组"></a>2.9.1 数组</h4><p>如果我们需要一个只包含数字的列表，那么array.array比list更高效。数组支持所有跟可变序列有关的操作，包括.pop、.insert和.extend。另外，数组还提供从文件读取和存入文件的更快的方法，如.frombytes和.tofile。</p>
<h4 id="2-9-2-内存视图"><a href="#2-9-2-内存视图" class="headerlink" title="2.9.2 内存视图"></a>2.9.2 内存视图</h4><h4 id="2-9-3-NumPy和SciPy"><a href="#2-9-3-NumPy和SciPy" class="headerlink" title="2.9.3 NumPy和SciPy"></a>2.9.3 NumPy和SciPy</h4><h4 id="2-9-4-双向队列和其他形式的队列"><a href="#2-9-4-双向队列和其他形式的队列" class="headerlink" title="2.9.4 双向队列和其他形式的队列"></a>2.9.4 双向队列和其他形式的队列</h4><h2 id="3-字典和集合"><a href="#3-字典和集合" class="headerlink" title="3 字典和集合"></a>3 字典和集合</h2><h3 id="3-1-泛映射类型"><a href="#3-1-泛映射类型" class="headerlink" title="3.1 泛映射类型"></a>3.1 泛映射类型</h3><h3 id="3-2-字典推导"><a href="#3-2-字典推导" class="headerlink" title="3.2 字典推导"></a>3.2 字典推导</h3><p>字典推导可以从任何以键值对作为元素的可迭代对象中构建出字典。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>DIAL_CODES = [</span><br><span class="line">...		(<span class="number">86</span>,<span class="string">&#x27;China&#x27;</span>),</span><br><span class="line">    	(<span class="number">91</span>,<span class="string">&#x27;India&#x27;</span>),</span><br><span class="line">    	...</span><br><span class="line">]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>country_code = &#123;country:code <span class="keyword">for</span> code , country <span class="keyword">in</span> DIAL_CODES&#125;</span><br><span class="line">&#123;<span class="string">&#x27;China&#x27;</span>:<span class="number">86</span>,<span class="string">&#x27;India&#x27;</span>:<span class="number">91</span>,....&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;code:country.upper() <span class="keyword">for</span> country, code <span class="keyword">in</span> country_code.items() <span class="keyword">if</span> code &lt; <span class="number">66</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>:<span class="string">&#x27;UNITED STATES&#x27;</span>, <span class="number">55</span>:<span class="string">&#x27;BRAZIL&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-常见的映射方法"><a href="#3-3-常见的映射方法" class="headerlink" title="3.3 常见的映射方法"></a>3.3 常见的映射方法</h3><h4 id="用setdefault处理找不到的键"><a href="#用setdefault处理找不到的键" class="headerlink" title="用setdefault处理找不到的键"></a>用setdefault处理找不到的键</h4><h2 id="4-文本和字节符"><a href="#4-文本和字节符" class="headerlink" title="4 文本和字节符"></a>4 文本和字节符</h2><p>。。。</p>
<h2 id="5-一等函数"><a href="#5-一等函数" class="headerlink" title="5 一等函数"></a>5 一等函数</h2><p>在Python中，函数是一等对象。编程语言理论家把”一等对象”定义为满足下述条件的程序实体:</p>
<ul>
<li>在运行时创建</li>
<li>能赋值给变量或数据结构中的元素</li>
<li>能作为参数传给函数</li>
<li>能作为函数的返回结果</li>
</ul>
<p>在Python中，整数、字符串和字典都是一等对象——没什么特别的。</p>
<h3 id="5-1-把函数视作对象"><a href="#5-1-把函数视作对象" class="headerlink" title="5.1 把函数视作对象"></a>5.1 把函数视作对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;returns n!&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt;<span class="number">2</span> <span class="keyword">else</span> n *factorial(n-<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>factorial(<span class="number">42</span>)</span><br><span class="line"><span class="number">140.</span>......</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>factoria.__doc__</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;returns n!&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(factoria)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">function</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>__doc__属性是用于生成对象的帮助文本。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact = factorial</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact</span><br><span class="line">&lt;function factorial at 0x...&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">map</span>(factorial,<span class="built_in">range</span>(<span class="number">11</span>))</span><br><span class="line">&lt;<span class="built_in">map</span> <span class="built_in">object</span> at 0x...&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-高阶函数"><a href="#5-2-高阶函数" class="headerlink" title="5.2 高阶函数"></a>5.2 高阶函数</h3><p>接受函数为参数，或者把函数作为结果返回的函数就是高阶函数。如map函数、sorted内置函数。</p>
<h4 id="map、filter和reduce的现代替代品"><a href="#map、filter和reduce的现代替代品" class="headerlink" title="map、filter和reduce的现代替代品"></a>map、filter和reduce的现代替代品</h4><p>由于引入了列表推导和生成器表达式，即使Python3中，map和filter还是内置函数，它们也变得没那么重要了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(fact,<span class="built_in">range</span>(<span class="number">6</span>)))</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">120</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[fact(n) <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>)]</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">120</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(factorial,<span class="built_in">filter</span>(<span class="keyword">lambda</span> n : n%<span class="number">2</span>,<span class="built_in">range</span>(<span class="number">6</span>))))</span><br><span class="line">[<span class="number">1</span>,<span class="number">6</span>,<span class="number">120</span>]</span><br><span class="line">&gt;&gt;&gt;[factorial(n) <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>) <span class="keyword">if</span> n % <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">6</span>,<span class="number">120</span>]</span><br></pre></td></tr></table></figure>

<h3 id="5-3-匿名函数"><a href="#5-3-匿名函数" class="headerlink" title="5.3 匿名函数"></a>5.3 匿名函数</h3><p>lambda关键字在Python表达式内创建匿名函数。</p>
<ul>
<li>lambda函数的定义体中不能赋值，也不能使用while和try等Python语句。</li>
<li>在参数列表中最适合使用匿名函数。</li>
<li>lambda句法只是语法糖：与def语句一样，lambda表达式会创建函数对象。这是Python中几种可调用对象的一种。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits = [<span class="string">&#x27;strawberry&#x27;</span>,<span class="string">&#x27;fig&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;cherry&#x27;</span>,<span class="string">&#x27;raspberry&#x27;</span>,<span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(fruits,key=<span class="keyword">lambda</span> word:word[::-<span class="number">1</span>])</span><br><span class="line">[<span class="string">&#x27;banana&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;fig&#x27;</span>,<span class="string">&#x27;raspberry&#x27;</span>,<span class="string">&#x27;cherry&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="5-4-可调用对象"><a href="#5-4-可调用对象" class="headerlink" title="5.4 可调用对象"></a>5.4 可调用对象</h3><p>除了用户定义的函数，调用运算符(即(）)还可以应用到其他对象上。如果想判断对象能否调用，可以使用内置的callable(）函数。Python数据模型文档列出了7种可调用对象。</p>
<ul>
<li><p>用户定义的函数</p>
<p>使用def语句或lambda表达式创建</p>
</li>
<li><p>内置函数</p>
<p>使用C语言CPython实现的函数，如len或time.strftime。</p>
</li>
<li><p>内置方法</p>
<p>使用C语言实现的方法，如dict.get。</p>
</li>
<li><p>方法</p>
<p>在类的定义体中定义的函数</p>
</li>
<li><p>类</p>
<p>调用类时会运行类定__new__方法创建一个实例，然后运行__init__方法，初始化实例，最后把实例返回给调用方。因为Python没有new运算符，所以调用类相当于</p>
</li>
</ul>
<h3 id="5-5-用户可定义的可调用类型"><a href="#5-5-用户可定义的可调用类型" class="headerlink" title="5.5 用户可定义的可调用类型"></a>5.5 用户可定义的可调用类型</h3><p>任何Python对象都可以表现得像函数。为此，只需实现实例方法__call__。</p>
<h3 id="5-6-函数内省"><a href="#5-6-函数内省" class="headerlink" title="5.6 函数内省"></a>5.6 函数内省</h3><p>使用dir函数可以探知函数factorial具有下列属性:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(factorial)</span><br><span class="line">[<span class="string">&#x27;__annotations__&#x27;</span>,<span class="string">&#x27;__call__&#x27;</span>,<span class="string">&#x27;__call__&#x27;</span>,<span class="string">&#x27;__closure__&#x27;</span>,<span class="string">&#x27;__code__&#x27;</span>,<span class="string">&#x27;__defaults__&#x27;</span>,<span class="string">&#x27;__delattr__&#x27;</span>,<span class="string">&#x27;__dict__&#x27;</span>,<span class="string">&#x27;__doc__&#x27;</span>,<span class="string">&#x27;__eq__&#x27;</span>,.....]</span><br></pre></td></tr></table></figure>





<ul>
<li>用户定义的函数的属性</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>__annotations__</td>
<td>dict</td>
<td>参数和返回值的注解</td>
</tr>
<tr>
<td>__call__</td>
<td>method-wrapper</td>
<td>实现()运算符：即可调用对象协议</td>
</tr>
<tr>
<td>__closure__</td>
<td>tuple</td>
<td>函数闭包，即自由变量的绑定</td>
</tr>
<tr>
<td>__code__</td>
<td>code</td>
<td>编译成字节码的函数元数据和函数定义体</td>
</tr>
<tr>
<td>__defaults__</td>
<td>tuple</td>
<td>形式参数的默认值</td>
</tr>
<tr>
<td>__get__</td>
<td>method-wrapper</td>
<td>实现只读描述协议</td>
</tr>
<tr>
<td>__globals__</td>
<td>dict</td>
<td>函数所在模块中的全局变量</td>
</tr>
<tr>
<td>__kwdefaults__</td>
<td>dict</td>
<td>仅限关键字形式参数的默认值</td>
</tr>
<tr>
<td>__name__</td>
<td>str</td>
<td>函数名称</td>
</tr>
<tr>
<td>__qualname__</td>
<td>str</td>
<td>函数的限定名称</td>
</tr>
</tbody></table>
<h3 id="5-7-从定位参数到仅限关键字参数"><a href="#5-7-从定位参数到仅限关键字参数" class="headerlink" title="5.7 从定位参数到仅限关键字参数"></a>5.7 从定位参数到仅限关键字参数</h3><ul>
<li>普通参数</li>
<li>可变参数</li>
<li>默认参数</li>
<li>关键字参数</li>
</ul>
<p>参数的定义顺序有一定要求:普通参数、可变参数、默认参数、关键字参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 生成HTML标签</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tag</span>(<span class="params">name,*content,cls=<span class="literal">None</span>,**attrs</span>):</span></span><br><span class="line">   <span class="keyword">if</span> cls <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    attrs[<span class="string">&#x27;class&#x27;</span>]=cls</span><br><span class="line">   <span class="keyword">if</span> attrs:</span><br><span class="line">        attr_str = <span class="string">&#x27;&#x27;</span>.join( <span class="string">&#x27;%s=&quot;%s&quot;&#x27;</span> % (attr,value) </span><br><span class="line">                           <span class="keyword">for</span> attr,value </span><br><span class="line">                           <span class="keyword">in</span> <span class="built_in">sorted</span>(attrs.items()))</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">    	attr_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  	<span class="keyword">if</span> content:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;\n&#x27;</span>.join(<span class="string">&#x27;&lt;%s%s&gt;%s&lt;/%s&gt;&#x27;</span> %</span><br><span class="line">                        (name,attr_str,c,name) <span class="keyword">for</span> c <span class="keyword">in</span> content)</span><br><span class="line">   	<span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;%s%s /&gt;&#x27;</span> % (name,attr_str)</span><br></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag(<span class="string">&#x27;br&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&lt;br /&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag(<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&lt;p&gt;hello&lt;/p&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(tag(<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>))</span><br><span class="line">&lt;p&gt;hello&lt;/p&gt;</span><br><span class="line">&lt;p&gt;world&lt;/p&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag(<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;hello&#x27;</span>,<span class="built_in">id</span>=<span class="number">33</span>)</span><br><span class="line"><span class="string">&#x27;&lt;p id=&quot;33&quot;&gt;hello&lt;/p&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(tag(<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>,cls=<span class="string">&#x27;sidebar&#x27;</span>))</span><br><span class="line">&lt;p class=&quot;sidebar&quot;&gt;hello&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;sidebar&quot;&gt;world&lt;/p&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag(content=<span class="string">&quot;testing&quot;</span>,name=<span class="string">&quot;img&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&lt;img content=&quot;testing&quot;/&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_tag = &#123;<span class="string">&#x27;name:&#x27;</span>img<span class="string">&#x27;,&#x27;</span>title<span class="string">&#x27;:&#x27;</span>Sunset Boulevard<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">             	&#x27;</span>src<span class="string">&#x27;:&#x27;</span>sunset.jpg<span class="string">&#x27;,&#x27;</span>cls<span class="string">&#x27;:&#x27;</span>framed<span class="string">&#x27;&#125;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; tag(**my_tag)</span></span><br><span class="line">&#x27;&lt;img class=&quot;framed&quot; src=&quot;sunset.jpg&quot; title =&quot;Sunset Boulevard&quot;/&gt;&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>仅限关键字参数是Python3新增的特性。在示例中，cls参数只能通过关键字参数指定，它一定不会捕获未命名的定位参数。定义函数时若想指定仅限关键字参数，要把他们放到前面有*的参数后面。如果不想支持数量不定的定位参数，但是想支持仅限关键字参数，在前面个中放一个*，如下所示:</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a,*,b</span>):</span></span><br><span class="line"><span class="meta">... </span>   <span class="keyword">return</span> a,b</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>,b=<span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>注意，仅限关键字参数不一定要有默认值，可以像上例中b那样，强制必须传入实参。</li>
</ul>
<h3 id="5-8-获取关于参数的信息"><a href="#5-8-获取关于参数的信息" class="headerlink" title="5.8 获取关于参数的信息"></a>5.8 获取关于参数的信息</h3><h3 id="5-9-函数注解"><a href="#5-9-函数注解" class="headerlink" title="5.9 函数注解"></a>5.9 函数注解</h3><h3 id="5-10-支持函数式编程的包"><a href="#5-10-支持函数式编程的包" class="headerlink" title="5.10 支持函数式编程的包"></a>5.10 支持函数式编程的包</h3><h4 id="5-10-1-operator模块"><a href="#5-10-1-operator模块" class="headerlink" title="5.10.1 operator模块"></a>5.10.1 operator模块</h4><h4 id="5-10-2-使用functools-partial冻结参数"><a href="#5-10-2-使用functools-partial冻结参数" class="headerlink" title="5.10.2 使用functools.partial冻结参数"></a>5.10.2 使用functools.partial冻结参数</h4><h2 id="7-函数装饰器和闭包"><a href="#7-函数装饰器和闭包" class="headerlink" title="7 函数装饰器和闭包"></a>7 函数装饰器和闭包</h2><p>函数装饰器用于在源码中，标记函数，以某种方式增强函数的行为。这是一项强大的功能，但是若想掌握，必须理解闭包。</p>
<p>除了在装饰器中有用处之外，闭包还是回调式异步编程和函数式编程风格的基础。</p>
<h3 id="7-1-装饰器基础知识"><a href="#7-1-装饰器基础知识" class="headerlink" title="7.1 装饰器基础知识"></a>7.1 装饰器基础知识</h3><p>装饰器是可调用的对象，其参数是另一个函数(被装饰的函数)。装饰器可能会处理被装饰的函数，然后把它返回，或者将其替换成另一个函数或可调用对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;running target()&#x27;</span>)</span><br><span class="line"><span class="comment"># 上述代码的效果与下述写法一样:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;running target()&#x27;</span>)</span><br><span class="line"></span><br><span class="line">target = decorate(target)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 装饰器通常会把函数替换成另一个函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">deco</span>(<span class="params">func</span>):</span></span><br><span class="line">    	<span class="built_in">print</span>(<span class="string">&#x27;running inner()&#x27;</span>)</span><br><span class="line">   	<span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@deco</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">target</span>():</span></span><br><span class="line"><span class="meta">... </span>   	<span class="built_in">print</span>(<span class="string">&#x27;running target()&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>target()</span><br><span class="line">running inner()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>target</span><br><span class="line">&lt;funtion deco.&lt;<span class="built_in">locals</span>&gt;.inner at <span class="number">0x10063b598</span>&gt; //target现在是inner的引用</span><br></pre></td></tr></table></figure>

<ul>
<li>装饰器只是语法糖</li>
<li>装饰器能把被装饰的函数替换成其他函数</li>
<li>装饰器在加载模块时立即执行</li>
</ul>
<h3 id="7-2-Python何时执行装饰器"><a href="#7-2-Python何时执行装饰器" class="headerlink" title="7.2 Python何时执行装饰器"></a>7.2 Python何时执行装饰器</h3><p>装饰器的一个关键特性是，它们在被装饰的函数定义之后立即运行。这通常是在导入时(即Python加载模块时)，如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">regsitry = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;running register(%s)&#x27;</span> % func)</span><br><span class="line">    registry.append(func)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;running f1()&#x27;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;running f2()&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;running f3()&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;running main()&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;registry -&gt;&#x27;</span>,registry)</span><br><span class="line">    f1()</span><br><span class="line">    f2()</span><br><span class="line">    f3()</span><br><span class="line">if__name__=<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python3 registration.py</span><br><span class="line">running register(&lt;function f1 at <span class="number">0x100631bf8</span>&gt;)</span><br><span class="line">running register(&lt;function f2 at <span class="number">0x100631c80</span>&gt;)</span><br><span class="line">running main()</span><br><span class="line">registry -&gt; [&lt;function f1 at 0x100631bf8&gt;,&lt;function f2 at 0x100631c80&gt;]</span><br><span class="line">running f1()</span><br><span class="line">running f2()</span><br><span class="line">running f3()</span><br></pre></td></tr></table></figure>



<p>如果导入registration.py模块(不作为脚本运行)，输出如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> registration</span><br><span class="line">running register(&lt;function f1 at <span class="number">0x10063b1e0</span>&gt;)</span><br><span class="line">running register(&lt;function f2 at <span class="number">0x10063b268</span>&gt;)</span><br></pre></td></tr></table></figure>

<p>此时查看registry的值，得到的输出如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>registration.registry</span><br><span class="line">[&lt;function f1 at <span class="number">0x10063b1e0</span>&gt;,&lt;function f2 at <span class="number">0x10063b268</span>&gt;]</span><br></pre></td></tr></table></figure>

<p>一般装饰器在真实代码中的常用模式</p>
<ul>
<li>装饰器通常在一个模块中定义，然后应用到其他模块中的函数上</li>
<li>大多数装饰器会在内部定义一个函数，然后将其返回。</li>
</ul>
<h3 id="7-3-使用装饰器改进“策略”模式"><a href="#7-3-使用装饰器改进“策略”模式" class="headerlink" title="7.3 使用装饰器改进“策略”模式"></a>7.3 使用装饰器改进“策略”模式</h3><p>使用注册装饰器可以改进6.1节中的电商促销折扣示例。</p>
<p>之前示例6-6的主要问题是，定义体中有函数的名称，但是best_promo用来判断哪个折扣幅度最大的promos列表中也有函数名称。这种重复是个问题，因为新增策略函数后可能会忘记把它添加到promos列表中，导致best_promo忽略新策略，而且不报错，为系统引入了不易察觉的缺陷。可以使用注册装饰器解决了这个问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">promos = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">promotion</span>(<span class="params">promo_func</span>):</span></span><br><span class="line">    promos.append(promo_func)</span><br><span class="line">    <span class="keyword">return</span> promo_func</span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity</span>(<span class="params">order</span>):</span></span><br><span class="line">    <span class="keyword">return</span> order.total()*<span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span>(<span class="params">order</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)</span><br></pre></td></tr></table></figure>

<h3 id="7-4-变量作用域规则"><a href="#7-4-变量作用域规则" class="headerlink" title="7.4 变量作用域规则"></a>7.4 变量作用域规则</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f2</span>(<span class="params">a</span>):</span></span><br><span class="line">    	<span class="built_in">print</span>(a)</span><br><span class="line">        <span class="built_in">print</span>(b)</span><br><span class="line">        b=<span class="number">9</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    UnboundLocalError:local variable <span class="string">&#x27;b&#x27;</span> referenced before assignment</span><br></pre></td></tr></table></figure>

<p>Python编译函数的定义体时，它判断b是局部变量，因为在函数中给它赋值了。生成的字节码证实了这种判断，Python会尝试从本地环境获取b。后面调用f2(3)时，f2的定义体会获取打印局部变量a的值，但是尝试获取局部变量b的值时，发现b没有绑定值。</p>
<p>这不是缺陷，而是设计选择：Python不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量。这比JavaScript的行为好多了，JavaScript也不要求声明变量，但是如果忘记把变量声明为局部变量(使用var)，可能会在不知情的情况下获取全局变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f3</span>(<span class="params">a</span>):</span></span><br><span class="line">    	<span class="keyword">global</span> b</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">        <span class="built_in">print</span>(b)</span><br><span class="line">        b = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">30</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">30</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="7-5-闭包"><a href="#7-5-闭包" class="headerlink" title="7.5 闭包"></a>7.5 闭包</h3><p>闭包指<strong>延伸了作用域的函数</strong>，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。函数是不是匿名的没有关系，关键是它能访问定义体之外定义的非全局变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span>():</span></span><br><span class="line">    series = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span>(<span class="params">new_value</span>):</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = <span class="built_in">sum</span>(series)</span><br><span class="line">        <span class="keyword">return</span> total / <span class="built_in">len</span>(series)</span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在averager函数中，series是自由变量。指未在本地作用域中绑定的变量。</p>
</li>
<li><p>averager的闭包延伸到那个函数的作用域之外，包含自由变量series的绑定。</p>
</li>
</ul>
<h3 id="7-6-nonlocal声明"><a href="#7-6-nonlocal声明" class="headerlink" title="7.6 nonlocal声明"></a>7.6 nonlocal声明</h3><p>前面实现make_averager函数的方法效率不高。更好的实现方式是，只存储目前的总值和元素个数，然后使用这两个数计算均值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span>():</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span>(<span class="params">new_value</span>):</span></span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line">        total+=new_value</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = make_averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line">Traceback(most recent call last):</span><br><span class="line">    ...</span><br><span class="line">UnboundLocalError:Local variable <span class="string">&#x27;count&#x27;</span> referenced before assignment</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>问题是，当count是数字或任何不可变类型时，count+=1语句其实与count=count+1一样。因此，我们在averager的定义体中为count赋值了，这会把count变成局部变量。total变量也受这个问题影响。</p>
<ul>
<li>上例中我们给series赋值，只是调用series.append，并把它传给sum和len。也就是说，我们利用了列表是可变的对象这一事实。</li>
<li>但是对数字、字符串、元组等不可变类型来说，只能读取，不能更新。如果尝试重新绑定，例如count=count+1,其实会隐式创建局部变量count。这样，count就不是自由变量了，因此不会保存在闭包中。</li>
</ul>
<p>为了解决这个问题，Python3引入了nonlocal声明，它的作用是把变量标记为自由变量，即使在函数中为变量赋予新值了，也会变成自由变量。如果为nonlocal声明的变量赋予新值，闭包中保存的绑定会更新。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span>():</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span>(<span class="params">new_value</span>):</span></span><br><span class="line">        <span class="keyword">nonlocal</span> count,total</span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line">        total+=new_value</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/29/%E6%B5%81%E7%95%85%E7%9A%84Python/" data-id="ckmunmoj1000bpcuu664795kp" data-title="流畅的Python" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-对象、类与面对对象编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/28/%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-03-28T04:03:29.000Z" itemprop="datePublished">2021-03-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>►<a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/28/%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">对象、类与面对对象编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>​    可以把ECMAScript的对象想象成一张散列表，其中的内容就是一组名/值对，值可以是数据或者函数。</p>
<p>[TOC]</p>
<h2 id="1-理解对象"><a href="#1-理解对象" class="headerlink" title="1 理解对象"></a>1 理解对象</h2><h2 id="2-创建对象"><a href="#2-创建对象" class="headerlink" title="2 创建对象"></a>2 创建对象</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>​    ECMAScript6开始正式支持类和继承。ES6的类旨在完全涵盖之前规范设计的基于原型的继承模板。不过，无论从哪方面看，ES6的类都仅仅是封装了ES5.1构造函数加原型继承的语法糖而已。</p>
<h3 id="2-2-工厂模式"><a href="#2-2-工厂模式" class="headerlink" title="2.2 工厂模式"></a>2.2 工厂模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name=name;</span><br><span class="line">    o.age=age;</span><br><span class="line">    o.job=job;</span><br><span class="line">    o.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = createPerson(<span class="string">&#x27;Nicholas&#x27;</span>,<span class="number">29</span>,<span class="string">&#x27;software Engineer&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = createPerson(<span class="string">&#x27;Greg&#x27;</span>,<span class="number">27</span>,<span class="string">&#x27;Doctor&#x27;</span>);</span><br></pre></td></tr></table></figure>



<p>​    这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决<strong>对象标识</strong>问题(即新创建的对象是什么类型)。</p>
<h3 id="2-3-构造函数模式"><a href="#2-3-构造函数模式" class="headerlink" title="2.3 构造函数模式"></a>2.3 构造函数模式</h3><p>​    ECMAScript6中的构造函数是用于创建特定类型对象的。像Object和Array这样的原生构造函数，运行时可以直接在执行环境中使用。当然也可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name=name;</span><br><span class="line">    <span class="built_in">this</span>.age=age;</span><br><span class="line">    <span class="built_in">this</span>.job=job;</span><br><span class="line">    <span class="built_in">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Nicholas&#x27;</span>,<span class="number">29</span>,<span class="string">&#x27;software Engineer&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">&#x27;Greg&#x27;</span>,<span class="number">27</span>,<span class="string">&#x27;Doctor&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>构造函数和工厂函数的区别：</p>
<ul>
<li><input disabled="" type="checkbox"> 没有显示地创建对象。</li>
<li><input disabled="" type="checkbox"> 属性和方法直接赋值给了this。</li>
<li><input disabled="" type="checkbox"> 没有return。</li>
</ul>
<p>要创建Person的实例，应使用new操作符。以这种方式调用构造函数会执行如下操作:</p>
<p>（1）在内存中创建一个新对象。</p>
<p>（2）这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype属性。</p>
<p><strong>1. 构造函数也是函数</strong></p>
<p>​    构造函数与普通函数唯一的区别就是调用方式不同。任何函数只要使用new操作符调用就是构造函数。而不使用new操作符调用的函数就是普通函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为构造函数</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;Nicholas&#x27;</span>,<span class="number">29</span>,<span class="string">&#x27;software Engineer&#x27;</span>);</span><br><span class="line">person.sayName();	<span class="comment">//&quot;Nicholas&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为函数调用</span></span><br><span class="line">Person(<span class="string">&#x27;Greg&#x27;</span>,<span class="number">27</span>,<span class="string">&#x27;Doctor&#x27;</span>);</span><br><span class="line"><span class="built_in">window</span>.sayName();	<span class="comment">//&quot;Greg&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> Oject();</span><br><span class="line">Person.call(o,<span class="string">&#x27;Kris&#x27;</span>,<span class="number">25</span>,<span class="string">&#x27;Singer&#x27;</span>);</span><br><span class="line">o.sayName();	<span class="comment">//&quot;kris&quot;</span></span><br></pre></td></tr></table></figure>



<p><strong>2. 构造函数的问题</strong></p>
<p>​    其定义的方法会在每个实例上都创建一遍，因为函数也是对象，因此每次定义函数时，都会初始化一个对象。逻辑上讲，这个构造函数实际上是这样的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name=name;</span><br><span class="line">    <span class="built_in">this</span>.age=age;</span><br><span class="line">    <span class="built_in">this</span>.job=job;</span><br><span class="line">    <span class="built_in">this</span>.sayName=<span class="keyword">new</span> <span class="built_in">Function</span>()<span class="built_in">console</span>.log(<span class="built_in">this</span>.name);	<span class="comment">//逻辑等价</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-4-原型模式"><a href="#2-4-原型模式" class="headerlink" title="2.4 原型模式"></a>2.4 原型模式</h3><p>​    每个函数都会创建一个prototype属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;	<span class="comment">//使用函数表达式也可以: let Person = function() &#123;&#125;;</span></span><br><span class="line">Person.prototype.name=<span class="string">&#x27;Greg&#x27;</span>;</span><br><span class="line">Person.prototype.age=<span class="number">29</span>;</span><br><span class="line">Person.prototype.job=<span class="string">&#x27;Singer&#x27;</span>;</span><br><span class="line">Person.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();	<span class="comment">//&quot;Greg&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName();	<span class="comment">//&quot;Greg&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName);	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<p><strong>1. 理解原型</strong></p>
<p>​    无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个prototype属性(指向原型对象)。默认情况下，所有原型对象自动获得一个名为constructor的属性，指回与之关联的构造函数。</p>
<p>​    在自定义构造函数时，原型对象默认只会获得constructor属性，其他的所有方法都继承自Object。每次调用构造函数创建一个新实例，这个实例的内部[[Prototype]]指针就会被赋值为构造函数的原型对象。脚本中没有访问这个[[Prototype]]特性的标准方式，但Firefox、Safari和Chrome会在每个对象上暴露__proto__属性，通过这个属性可以访问对象的原型。在其他实现中，这个特性完全被隐藏了。关键在于理解这一点:实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有。</p>
<p><strong>2. 原型层级</strong></p>
<h2 id="3-继承"><a href="#3-继承" class="headerlink" title="3 继承"></a>3 继承</h2><p>​    很多面向对象语言都支持两种继承：接口继承和实现继承。前者只继承方法签名，后者继承实际的方法。接口继承在ECMAScript中是不可能的，因为函数没有签名。实现继承是ECMAScript唯一支持的继承方式，而这主要是通过<strong>原型链</strong>实现的。</p>
<h3 id="3-1-原型链"><a href="#3-1-原型链" class="headerlink" title="3.1 原型链"></a>3.1 原型链</h3><p>​    ECMA-262把原型链定义为ECMAScript的主要继承方式。其基本思想就是通过原型继承多个引用类型的属性和方法。重温一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue());	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><img src="images/%E5%8E%9F%E5%9E%8B%E9%93%BE1.JPG"><br>​    这个例子中实现继承的关键，是SubType没有使用默认原型，而是将其替换成了一个新的对象。这个新的对象恰好是SuperType的实例。这样一来，SubType的实例不仅能从SuperType的实例中继承属性和方法，而且还与SuperType的原型挂上了钩。于是instance(通过内部的[[Prototype]])指向SubType.prototype，而SubType.prototype(作为SuperType的实例又通过内部的[[Prototype]])指向SuperType.prototype。注意，getSuperValue()方法还在SuperType.prototype对象上，而property属性则在SubType.prototype上。这是因为getSuperValue()是一个原型方法，而property是一个实例属性。SubType.prototype的constructor属性被重写为指向SuperType，所以instance.constructor也指向SuperType。</p>
<p>​    原型链扩展了前面描述的<strong>原型搜索机制</strong>。我们知道，在读取实例上的属性时，首先会在实例上搜索这个属性。如果没找到，则会继承搜索实例的原型。在通过原型链实现继承之后，搜索就可以继承向上，搜索原型的原型。如调用instance.getSuperValue()经过了3步搜索：instance、SubType.prototype和SuperType.prototype，最后一步才找到这个方法。对属性和方法的搜索会一直持续到原型链的末端。</p>
<p><strong>1. 默认原型</strong></p>
<p>​    实际上，原型链中还有一环。默认情况下，所有引用类型都继承自Object，这也是通过原型链实现的。任何函数的默认原型都是一个Objecr的实例，这意味着这个实例有一个内部指针指向Object.prototype。这也是为什么自定义类型能够继承包括toString()、valueOf()在内部的所有默认方法的原因。因此在前面的例子还有额外一层继承关系。下图展示了完整的原型链。</p>
<p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE2.JPG"></p>
<p>OAOAOA</p>
<p><strong>2. 原型与继承关系</strong></p>
<p>​    原型与实例的关系可以通过两种方式来确定：</p>
<ul>
<li><em>instanceof</em>操作符：如果一个实例的原型链中出现过相应的构造函数，则<em>instanceof</em>返回true。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(instance instancof <span class="built_in">Object</span>);	<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance instancof SuperType);	<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance instancof SubType);	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<ul>
<li>使用*isPrototypeOf()*方法：原型链中的每个原型都可以调用这个方法，只要原型链中包含这个原型，这个方法就返回true;</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance));	<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(SuperType.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(SubType.prototype.isPrototypeOf(instance));	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 关于方法</strong></p>
<p>​    子类有时候需要覆盖父类的方法，或者增加父类没有的方法。为此，这些方法必须在原型赋值之后再添加到原型上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">**</span><br><span class="line"><span class="comment">//新方法</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//覆盖已有的方法</span></span><br><span class="line">SubType.prototype.getSuperValue = <span class="function"><span class="title">funtion</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line">**</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue());	<span class="comment">//false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    SubType实例上调用getSuperValue()时调用的是这个方法，而SuperType的实例仍然会调用最初的方法。重点在于上述两个方法都是在把原型赋值为SubperType的实例之后定义的。</p>
<p>​    <strong>注意：</strong> 以对象字面量方式创建原型方法会破坏之前的原型链，因为这相当于重写了原型链。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过对象字面量添加新方法，这会导致上一行无效</span></span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line">    <span class="function"><span class="title">getSubValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">someOtherMethod</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue());	<span class="comment">//出错!</span></span><br></pre></td></tr></table></figure>

<p>​    在这段代码中，子类的原型在被赋值为SuperType的实例后，又被一个对象字面量覆盖了。覆盖后的原型是一个Object的实例，而不是SuperType的实例。因此之前的原型链就断了。SuperType和SubType之间也没有关系了。</p>
<p><strong>4. 原型链的问题</strong></p>
<p>​    原型的第一个问题：原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变变成了原型属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>,<span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">&#x27;black&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);<span class="comment">//&quot;red,blue,green,black&quot;</span></span><br></pre></td></tr></table></figure>

<p>​    如果colors不是引用值，就不会出现这个问题了。</p>
<ul>
<li>原型的第二个问题是，子类型在实例化时不能给父类型的构造函数传参。事实上，我们无法在不影响所有对象实例的情况下把参数传进父类的构造函数。再加上之前提到的原型中包含引用值的问题，就导致原型链基本不会被单独使用。</li>
</ul>
<h3 id="3-2-盗用构造函数"><a href="#3-2-盗用构造函数" class="headerlink" title="3.2 盗用构造函数"></a>3.2 盗用构造函数</h3><p>​    为了解决原型包含引用值导致的继承问题，一种叫作”盗用构造函数”的技术流行起来。基本思路很简单：在子类构造函数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用*apply()<em>和</em>call()*方法以新创建的对象为上下文执行构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>,<span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">**</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承SuperType</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">**</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">&#x27;black&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);	<span class="comment">//&#x27;red,blue,green,black&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instace2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);	<span class="comment">//&#x27;red,blue,green&#x27;</span></span><br></pre></td></tr></table></figure>

<p>​    通过使用call()或apply()方法，SuperType构造函数在为SubType的实例创建的新对象的上下文中执行了。这相当于新的SubType对象上运行了SuperType()函数中的所有初始化代码。结果就是每个实例都会有自己的colors属性。</p>
<p><strong>1. 传递参数</strong></p>
<p>​    相比于使用原型链，盗用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承SuperType并传参</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>,<span class="string">&#x27;Nicholas&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例属性</span></span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.name);	<span class="comment">//&#x27;Nicholas&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.age);	<span class="comment">//29</span></span><br></pre></td></tr></table></figure>





<p><strong>2. 盗用构造函数的问题</strong></p>
<p>​    盗用构造函数的主要缺点，也是使用构造函数模式自定义类型的问题：必须在构造函数中定义方法，因此函数不能重用。此外，子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。由于存在这些问题，盗用构造函数基本上也不能单独使用。</p>
<h3 id="3-3-组合继承"><a href="#3-3-组合继承" class="headerlink" title="3.3 组合继承"></a>3.3 组合继承</h3><p>​    组合继承综合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>,<span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//继承SuperType并传参</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>,name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例属性</span></span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="title">funtion</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">&quot;Nicholas&quot;</span>,<span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);	<span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line">instance1.sayName();	<span class="comment">//&quot;Nicholas&quot;</span></span><br><span class="line">instance1.sayAge();	<span class="comment">//29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">&quot;Greg&quot;</span>,<span class="number">27</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);	<span class="comment">//&quot;red,blue,green&quot;</span></span><br><span class="line">instance1.sayName();	<span class="comment">//&quot;Greg&quot;</span></span><br><span class="line">instance1.sayAge();	<span class="comment">//27</span></span><br></pre></td></tr></table></figure>

<p>​    组合继承弥补了原型链和构造函数的不足，是JavaScript中使用最多的继承模式。而且组合继承也保留了<em>instanceof</em>操作符和*isPrototypeOf()*方法识别合成对象的能力。</p>
<h3 id="3-4-原型式继承"><a href="#3-4-原型式继承" class="headerlink" title="3.4 原型式继承"></a>3.4 原型式继承</h3><p>​    原型式继承，是一种不涉及严格意义上构造函数的继承方法。即使不自定义类型也可以通过原型实现对象之间的信息共享。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    funtion <span class="function"><span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这个object()函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。本质上，object()是对传入的对象执行了一次浅复制。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person =&#123;</span><br><span class="line">    name:<span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    friends:[<span class="string">&quot;Shelby&quot;</span>,<span class="string">&quot;Court&quot;</span>,<span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anothorPerson = object(person);</span><br><span class="line">anothorPerson.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">anothorPerson.friends.push(<span class="string">&quot;Rob&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> yetAnothorPerson = object(person);</span><br><span class="line">yetAnothorPerson.name = <span class="string">&quot;Linda&quot;</span>;</span><br><span class="line">yetAnothorPerson.friends.push(<span class="string">&quot;Barbie&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.friends);	<span class="comment">//&quot;Shelby,Court&quot;,Van,Rob,Barbie&quot;</span></span><br></pre></td></tr></table></figure>

<p>​    原型式继承适用于这种情况：你有一个对象，想在它的基础上再创建一个新对象。你需要把这个对象先传给object()，然后再对返回的对象进行适当修改。person对象定义了另一个也应该共享的信息，把它传给object()之后会返回一个新对象。这个新对象的原型是person，意味着它的原型上既有原始值属性又有引用值属性。</p>
<p>​    ECMAScript5通过增加Object.create()方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象(可选参数)。在只有一个参数时，Object.create()与这里的object()方法效果相同：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person =&#123;</span><br><span class="line">    name:<span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    friends:[<span class="string">&quot;Shelby&quot;</span>,<span class="string">&quot;Court&quot;</span>,<span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anothorPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">anothorPerson.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">anothorPerson.friends.push(<span class="string">&quot;Rob&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> yetAnothorPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">yetAnothorPerson.name = <span class="string">&quot;Linda&quot;</span>;</span><br><span class="line">yetAnothorPerson.friends.push(<span class="string">&quot;Barbie&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.friends);	<span class="comment">//&quot;Shelby,Court&quot;,Van,Rob,Barbie&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person3 = <span class="built_in">Object</span>.create(person,&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        value:<span class="string">&quot;Greg&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person3.name);	<span class="comment">//&quot;Greg&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="3-5-寄生式继承"><a href="#3-5-寄生式继承" class="headerlink" title="3.5 寄生式继承"></a>3.5 寄生式继承</h3><p>​    与原型式继承比较接近的一种继承方式是寄生式继承，也是Crockford首倡的一种模式。寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。基本的寄生继承模式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> clone = object(original);	<span class="comment">//通过调用函数创建一个新对象</span></span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	<span class="comment">//以某种方式增强这个对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone;	<span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    createAnother()函数接收一个参数，就是新对象的基准对象。这个对象original会被传给object()函数，然后将返回的新对象赋值给clone。接着给clone对象添加一个新方法sayHi()。</p>
<p>​    寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景。object()函数不是寄生式继承所必需的，任何返回新对象的函数都可在这里使用。</p>
<h3 id="3-6-寄生式组合继承"><a href="#3-6-寄生式组合继承" class="headerlink" title="3.6 寄生式组合继承"></a>3.6 寄生式组合继承</h3><p>​    组合继承其实也存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在子类构造函数中调用。本质上，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>,<span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    SuperType.call(<span class="built_in">this</span>,name);	<span class="comment">//第二次调用SuperType()</span></span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();	<span class="comment">//第一次调用SuperType()</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>,age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​    <img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE3.JPG"></p>
<p>​    <img src="images/%E5%8E%9F%E5%9E%8B%E9%93%BE4.JPG"><br>​    有两组name和colors属性：一组在实例上，另一组在SubType的原型上。这是调用两次SuperType构造函数的结果。好在有办法解决这个问题。</p>
<p>​    寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给予子类原型。寄生式组合继承的基本模式如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType,superType</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prototype = object(superType.prototype);	<span class="comment">//创建对象</span></span><br><span class="line">    prototype.constructor = subType;				<span class="comment">//增强对象</span></span><br><span class="line">    subType.prototype = prototype;					<span class="comment">//赋值对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这个inheritPrototype()函数实现了寄生式组合继承的核心逻辑。这个函数接收两个参数：子类构造函数和父类构造函数。在这个函数内部，第一步是创建父类原型的一个副本。然后，给返回的prototype对象设置constructor属性，解决由于重写原型导致默认constructor丢失的问题。最后将新创建的对象赋值给予类型的原型。如下例所示，调用inheritPrototype()就可以实现前面例子中的子类型原型赋值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>,<span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    SuperType.call(<span class="built_in">this</span>,name);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**</span><br><span class="line">inheritPrototype(SubType,SuperType);</span><br><span class="line">**</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="title">funtion</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    这里只调用了一次SUperType的构造函数，避免了SubType.prototype上不必要也用不到的属性，因此也可以说这个例子的效率更高。而且，原型键仍然保持不变，因此instanceof操作符和isPrototypeOf()方法正常有效。<strong>寄生式组合继承</strong>可以算是引用类型继承的最佳模式。</p>
<h2 id="4-类"><a href="#4-类" class="headerlink" title="4 类"></a>4 类</h2><h3 id="4-1-类定义"><a href="#4-1-类定义" class="headerlink" title="4.1 类定义"></a>4.1 类定义</h3><h3 id="4-2-类构造函数"><a href="#4-2-类构造函数" class="headerlink" title="4.2 类构造函数"></a>4.2 类构造函数</h3><h3 id="4-3-实例、原型和类成员"><a href="#4-3-实例、原型和类成员" class="headerlink" title="4.3 实例、原型和类成员"></a>4.3 实例、原型和类成员</h3><p>​    类的语法可以非常方便地定义应该在于实例上的成员、应该存在于原型上的成员，以及应该存在于类本身的成员。</p>
<h4 id="1-实例成员"><a href="#1-实例成员" class="headerlink" title="1. 实例成员"></a>1. 实例成员</h4><p>​    每次通过new调用类标识符时，都会执行类构造函数。在这个函数内部，可以为新创建的实例(this)添加”自有”属性。至于添加什么样的属性，则没有限制。另外，在构造函数执行完毕后，仍然可以给实例继续添加新成员。</p>
<p>​    每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>,name = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>,sayName = <span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">        <span class="built_in">this</span>.nicknames = [<span class="string">&#x27;Jack&#x27;</span>,<span class="string">&#x27;J-Dog&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(),</span><br><span class="line">    p2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">p1.sayName(); <span class="comment">//Jack</span></span><br><span class="line">p2.sayName(); <span class="comment">//Jack</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.name === p2.name); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.sayName === p2.sayName); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.nicknames === p2.nicknames); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">p1.name = p1.nicknames[<span class="number">0</span>];</span><br><span class="line">p2.name = p2.nicknames[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">p1.sayName();	<span class="comment">//Jake</span></span><br><span class="line">p1.sayName();	<span class="comment">//J-Dog</span></span><br></pre></td></tr></table></figure>

<h4 id="2-原型方法与访问器"><a href="#2-原型方法与访问器" class="headerlink" title="2. 原型方法与访问器"></a>2. 原型方法与访问器</h4><p>​    为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.locate = <span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="string">&#x27;instance&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在类块中定义的所有内容都会定义在类的原型上</span></span><br><span class="line">    <span class="function"><span class="title">locate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;prototype&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">p.locate();					 <span class="comment">//instance</span></span><br><span class="line">Person.prototype.locate();	<span class="comment">//prototype</span></span><br></pre></td></tr></table></figure>

<p>​    可以把方法定义在类构造函数中或者类块中，但不能在类块中给原型添加原始值或对象作为成员数据。</p>
<h4 id="3-静态类方法"><a href="#3-静态类方法" class="headerlink" title="3. 静态类方法"></a>3. 静态类方法</h4><p>​    可以在类上定义静态方法。这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。与原型成员类似，每个类上只能有一个静态成员。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.locate = <span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="string">&#x27;instance&#x27;</span>,<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义在类的原型对象上</span></span><br><span class="line">    <span class="function"><span class="title">locate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;prototype&#x27;</span>,<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义在类本身上</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">locate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;class&#x27;</span>,<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">p.locate();					 <span class="comment">//instance,Person()</span></span><br><span class="line">Person.prototype.locate();	<span class="comment">//prototype, &#123;constructor:...&#125;</span></span><br><span class="line">Person.locate();			<span class="comment">//class,class Person&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-非函数原型和类成员"><a href="#4-非函数原型和类成员" class="headerlink" title="4. 非函数原型和类成员"></a>4. 非函数原型和类成员</h4><p>​    类定义中之所以没有显示支持添加数据成员，是因为在共享目标(原型和类)上添加可变数据成员是一种反模式。一般来说，对象实例应该独自拥有通过this引用的数据。也可在类定义外部，手动添加。</p>
<h4 id="5-迭代器与生成器方法"><a href="#5-迭代器与生成器方法" class="headerlink" title="5. 迭代器与生成器方法"></a>5. 迭代器与生成器方法</h4><h3 id="4-4-继承"><a href="#4-4-继承" class="headerlink" title="4.4 继承"></a>4.4 继承</h3><p>​    ES6新增特性中最出色的一个就是原生支持了类继承机制。虽然类继承使用的是新语法，但背后依旧使用的是原型链。</p>
<p><strong>1. 继承基础</strong></p>
<p><strong>2. 构造函数、HomeObject和super()</strong></p>
<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h2><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210313220450103.png" alt="image-20210313220450103" style="zoom:80%;" />



      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/28/%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" data-id="ckmunmoiz000apcuucey12pr5" data-title="对象、类与面对对象编程" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-搭建Hexo博客" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/28/%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/" class="article-date">
  <time class="dt-published" datetime="2021-03-28T03:19:24.000Z" itemprop="datePublished">2021-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/28/%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/">搭建Hexo博客</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="搭建Hexo博客-的填坑之路······"><a href="#搭建Hexo博客-的填坑之路······" class="headerlink" title="搭建Hexo博客 的填坑之路······"></a>搭建Hexo博客 的填坑之路······</h1><blockquote>
<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
</blockquote>
<p>参考</p>
<ul>
<li>hexo官方文档：<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/index.html">https://hexo.io/zh-cn/docs/index.html</a></li>
<li>超详细Hexo+Github博客搭建小白教程 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35668237">https://zhuanlan.zhihu.com/p/35668237</a><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3></li>
<li>Node.js（Node.js版本需不低于8.10,建议使用Node.js 10.0及以上版本）</li>
<li>Git</li>
</ul>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>   安装前确保已经安装好node.js和Git环境。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul>
<li>使用<code>$ npm install -g hexo-cli</code>安装太慢</li>
<li>改用<code>$ cnpm install -g hexo-cli</code>安装过程中，由于我的node版本是v6.11.3，一直会提醒我node&gt;=8，安装完毕后，输入<code>$ hexo -v</code>，报错：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;hexo -v</span><br><span class="line">G:\environment\node\node_global\node_modules\hexo-cli\node_modules\_chokidar@3.3.1@chokidar\index.js:151</span><br><span class="line">  async remove(item) &#123;</span><br><span class="line">        ^^^^^^</span><br><span class="line"></span><br><span class="line">SyntaxError: Unexpected identifier</span><br><span class="line">    at createScript (vm.js:56:10)</span><br><span class="line">    at Object.runInThisContext (vm.js:97:10)</span><br><span class="line">    at Module._compile (module.js:542:28)</span><br><span class="line">    at Object.Module._extensions..js (module.js:579:10)</span><br><span class="line">    at Module.load (module.js:487:32)</span><br><span class="line">    at tryModuleLoad (module.js:446:12)</span><br><span class="line">    at Function.Module._load (module.js:438:3)</span><br><span class="line">    at Module.require (module.js:497:17)</span><br><span class="line">    at require (internal&#x2F;module.js:20:19)</span><br><span class="line">    at Object.&lt;anonymous&gt; (G:\environment\node\node_global\node_modules\hexo-cli\node_modules\_hexo-fs@2.0.0@hexo-fs\lib\fs.js:6:18)</span><br><span class="line">    at Module._compile (module.js:570:32)</span><br><span class="line">    at Object.Module._extensions..js (module.js:579:10)</span><br><span class="line">    at Module.load (module.js:487:32)</span><br><span class="line">    at tryModuleLoad (module.js:446:12)</span><br><span class="line">    at Function.Module._load (module.js:438:3)</span><br><span class="line">    at Module.require (module.js:497:17)</span><br></pre></td></tr></table></figure>
百度检查hexo版本报错后，没有得到什么答案，又百度node.js版本过低影响安装hexo吗？<br>一直没有搜索到相关的答案，决定尝试更新node.js版本！！！<h3 id="升级（重新安装）Node-js"><a href="#升级（重新安装）Node-js" class="headerlink" title="升级（重新安装）Node.js"></a>升级（重新安装）Node.js</h3>百度说，在windows下是没有n模块，不支持通过n模块来更新node.js。只能重新安装node.js</li>
</ul>
<ol>
<li>在命令行窗口输入where node，查看现在Node版本安装的路径</li>
<li>在node官网下载与你电脑系统对应的最新的版本，安装地址一定要覆盖原版本的地址</li>
<li>在命令行输入node -v，查看版本是否更新成功<h3 id="再次安装hexo"><a href="#再次安装hexo" class="headerlink" title="再次安装hexo"></a>再次安装hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo -v</span><br></pre></td></tr></table></figure>
成功！！！</li>
</ol>
<h3 id="进阶安装和使用"><a href="#进阶安装和使用" class="headerlink" title="进阶安装和使用"></a>进阶安装和使用</h3><p>对于熟悉npm的进阶用户，可以仅局部安装hexo包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo</span><br></pre></td></tr></table></figure>
<p>安装以后，可以使用以下两种方式执行Hexo:</p>
<ol>
<li><code>npx hexo &lt;command&gt;</code></li>
<li>将Hexo所在的目录下的node_modules添加到环境变量之中即可直接使用<code>hexo &lt;command&gt;</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#39;PATH&#x3D;&quot;$PATH:.&#x2F;node_modules&#x2F;.bin&quot;&#39; &gt;&gt; ~&#x2F;.profile</span><br></pre></td></tr></table></figure>
<h2 id="2-本地搭建hexo博客"><a href="#2-本地搭建hexo博客" class="headerlink" title="2. 本地搭建hexo博客"></a>2. 本地搭建hexo博客</h2>安装Hexo完成后，新建文件夹。在该文件夹右键 git bash here<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>
完成之后输入：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br><span class="line">$ hexo g &#x2F;&#x2F;生成静态网页</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server &#x2F;&#x2F;打开本地服务器</span><br></pre></td></tr></table></figure>
之后，浏览器访问<a href="http://localhost:4000，即可看到hexo博客页面。">http://localhost:4000，即可看到hexo博客页面。</a></li>
</ol>
<p>但我又失败了，访问<a href="http://localhost，显示无法访问网站。这个问题又搜索不到原因？？？？">http://localhost，显示无法访问网站。这个问题又搜索不到原因？？？？</a></p>
<p>最后再看hexo官方文档，在基本操作/服务器中，发现文档中写：</p>
<blockquote>
<p>Hexo 3.0 把服务器独立成了个别模块，您必须先安装 hexo-server 才能使用。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-server --save</span><br></pre></td></tr></table></figure>
<p>再次打开服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server &#x2F;&#x2F;打开本地服务器</span><br></pre></td></tr></table></figure>
<p>终于成功！！!</p>
<p>新建完成后，指定文件夹的目录如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<h2 id="3-将博客托管到Github上"><a href="#3-将博客托管到Github上" class="headerlink" title="3.将博客托管到Github上"></a>3.将博客托管到Github上</h2><p>打开博客根目录下的_config.yml文件，这是博客的配置文件，可以修改与博客相关的各种信息。<br>修改配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;username.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>reository修改为你自己的github地址</p>
<h3 id="写文章、发布文章"><a href="#写文章、发布文章" class="headerlink" title="写文章、发布文章"></a>写文章、发布文章</h3><p>在博客根目录下右键git bash，安装一个扩展<code>npm i hexo-deployer-git</code><br>输入<code>hexo new post &lt;title&gt;</code>，新建一篇文章。<br>再打开博客目录，可以发现多了一个文件夹和一个.md文件，用来存放图片，和编写markdown文件。<br>编写完markdown文件后，根目录输入hexo g 生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这是打开你的github.io主页就能看到发布的文章了。</p>
<h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>现在默认域名是xxx.github.io，如果像弄一个专属域名。购买完域名后，打开github博客项目，点击settings，拉到下面Custom domain处。填上自己的域名这时候你的项目根目录应该会出现一个名为CNAME的文件了。如果没有的话，打开你本地博客/source目录，我的是D:\study\program\blog\source，新建CNAME文件，注意没有后缀。然后在里面写上你的域名，保存。最后运行hexo g、hexo d上传到github。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/28/%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/" data-id="ckmunmoi40005pcuuf1w61qko" data-title="搭建Hexo博客" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-test-first-article" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/28/test-first-article/" class="article-date">
  <time class="dt-published" datetime="2021-03-28T03:13:21.000Z" itemprop="datePublished">2021-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/28/test-first-article/">test first article</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="test-my-first-article"><a href="#test-my-first-article" class="headerlink" title="test my first article"></a>test my first article</h2><p>Test<br>Test</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/28/test-first-article/" data-id="ckmunmoi10003pcuu8nb1cga9" data-title="test first article" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/28/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-03-28T03:01:04.678Z" itemprop="datePublished">2021-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/28/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/28/hello-world/" data-id="ckmunmohx0001pcuu1gm0946u" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/">书籍笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/%E6%B5%81%E7%A8%8B%E7%9A%84Python/">流程的Python</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/">Python</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/29/JavaScript%E5%BE%AE%E8%BD%AF%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B/">JavaScript微软官方教程</a>
          </li>
        
          <li>
            <a href="/2021/03/29/%E6%B5%81%E7%95%85%E7%9A%84Python/">流畅的Python</a>
          </li>
        
          <li>
            <a href="/2021/03/28/%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">对象、类与面对对象编程</a>
          </li>
        
          <li>
            <a href="/2021/03/28/%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/">搭建Hexo博客</a>
          </li>
        
          <li>
            <a href="/2021/03/28/test-first-article/">test first article</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>